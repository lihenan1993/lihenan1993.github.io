---
title: 事务和锁
category: MySQL是怎样运行的
typora-root-url: ../../
---

 

# 事务

ACID原则：

A原子性：事务具有原子性，指的是一个事务要么做完，要么失败，不能只执行其中一部分操作

C一致性：事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。

如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这是数据库就处于一种不正确的状态，也就是不一致的状态

I隔离行：事务的隔离性是指在**并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。**

D持久性：一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。

## 并发事务访问相同记录的情况

1. 读 - 读情况

   读不会操作记录，所以允许这种情况

2. 读 - 写 或 写 - 读 情况

   即一个事务读，另一个事务改动记录。通过MVCC解决

3. 写 - 写 情况

   并发事务相继对相同的记录进行改动，锁解决



## 事务并发执行时遇到的一致性问题

- 脏写

  一个事务修改了另一个未提交事务修改过的数据

- 脏读

  一个事务读到了另一个未提交事务修改过的数据

- 不可重复读

  一个事务**修改** （UPDATE）了另一个未提交事务读取的数据

- 幻读

  一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录（INSERT DELETE UPDATE），之前事务再次搜索的时候，**会读到第一次没有读到的记录**。

  这些记录被称为幻影记录，这个现象被称为幻读。
  
  > 这种幻读可以通过MVCC来解决
  >
  > 但是如果另一个事务把修改提交了，MVCC就没办法了

## SQL标准中的4中隔离级别

牺牲一部分隔离性来换取性能

SQL标准中的隔离级别：

1. READ UNCOMMITTED 未提交读
2. READ COMMITTED 已提交读
3. REPEATABLE READ 可重复读
4. SERIALIZABLE 可串行化

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ UNCOMMITTED | 可能 | 可能       | 可能 |
| READ COMMITTED   | No   | 可能       | 可能 |
| REPEATABLE READ  | No   | No         | 可能 |
| SERIALIZABLE     | No   | No         | No   |



脏写现象是任何隔离级别都不允许的，MySQL通过锁来解决脏写的问题

## MVCC原理

InnoDB存储引擎，聚簇索引记录中包含两个必要的隐藏列

- trx_id：一个事务每次对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列
- roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中

每次更新记录后，都会把旧值放到一条undo日志中（该记录的一个旧版本），新记录指向旧记录，会形成版本链。

![image-20210105104523514](/assets/img/image-20210105104523514.png)



#### 多版本并发控制 MVCC定义

在使用 读已提交和可重复读 隔离级别的事务执行**普通的SELECT语句**时，访问记录版本链的过程。

MVVC  使得不同事务的 读-写，写-读 操作并发执行而不加锁，提升了数据库的并发性能。



## ReadView 一致性视图

MySQL如何解决幻读问题

- read uncommitted隔离级别事务：直接读取记录的最新版本；

- serializable隔离级别事务：使用加锁的方式来访问记录；

- RC和RR隔离级别事务：需要用到版本链概念，核心问题是如何判断版本链中哪个版本是当前事务可见的？

- readview中四个比较重要的概念：

- - `m_ids`：表示在生成`ReadView`时当前系统中活跃的读写事务的`事务id`列表。

  - `min_trx_id`：表示在生成`ReadView`时当前系统中活跃的读写事务中最小的`事务id`，也就是`m_ids`中的最小值。

  - `max_trx_id`：表示生成`ReadView`时系统中应该分配给下一个事务的`id`值。

    > 小贴士： 注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。

  - `creator_trx_id`：表示生成该`ReadView`的事务的`事务id`。

    > 小贴士： 我们前边说过，只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，**否则在一个只读事务中的事务id值都默认为0**。

- 有了这个`ReadView`，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

- - 如果被访问版本的`trx_id`属性值与`ReadView`中的`creator_trx_id`值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
  - 如果被访问版本的`trx_id`属性值小于`ReadView`中的`min_trx_id`值，表明生成该版本的事务在当前事务生成`ReadView`前已经提交，所以该版本可以被当前事务访问。
  - 如果被访问版本的`trx_id`属性值大于或等于`ReadView`中的`max_trx_id`值，表明生成该版本的事务在当前事务生成`ReadView`后才开启，所以该版本不可以被当前事务访问。
  - 如果被访问版本的`trx_id`属性值在`ReadView`的`min_trx_id`和`max_trx_id`之间，那就需要判断一下`trx_id`属性值是不是在`m_ids`列表中，如果在，说明创建`ReadView`时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建`ReadView`时生成该版本的事务已经被提交，该版本可以被访问。

- 如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。

- 在`MySQL`中，`READ COMMITTED`和`REPEATABLE READ`隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。

- - READ COMMITTED —— 每次读取数据前都生成一个ReadView
  - REPEATABLE READ —— 在第一次读取数据时生成一个ReadView，之后再读数据时，重复使用该ReadView



## 二级索引与MVCC

只有聚簇索引中才有trx_id 和 roll_pointer 隐藏列

如果使用二级索引查询的时候

1. 二级索引的Page Header  的  PAGE_MAX_TRX_ID 会记录，对该记录修改的最新trx_id ，如果与当前活跃trxid相同，说明记录可见，否则回表再判断



# 锁

写 - 写情况会发生脏写，任何一种隔离级别都不允许这种现象发生。

所以再多个未提交事务相继对一条记录进行修改时，需要让它们排队进行。

这个排队的过程就是通过对记录加锁实现的

“锁”本质上是一个内存中的结构



![image-20210105115357002](/assets/img/image-20210105115357002.png)

trx：表示锁结构是与哪个事务关联的

is_waiting: 表示当前事务是否在等待

1. T1改动记录前，成功生成一个锁结构，并且没有别的事务对该记录加锁，则is_waiting = false ，获锁成功。
2. T2需要等待，获锁失败



## 快照读 - 一致性读

事务利用MVCC进行的读取操作称为一致性读 或 快照读。

所有普通的SELECTURE语句 ，在 读已提交 和 可重复读 隔离级别下都算是一致性读

一致性读不会对表中的任何记录进行加锁操作



## 锁定读

### 共享锁 和 独占锁

- 共享锁（Shared Lock  S锁）

  在事务要读取一条记录时，需要先获取记录的S锁

- 独占锁（Exclusive Lock X锁 排他锁）

  在事务要改动一条记录时，需要先获取该记录的X锁

| 兼容性 | X锁    | S锁    |
| ------ | ------ | ------ |
| X锁    | 不兼容 | 不兼容 |
| S锁    | 不兼容 | 兼容   |



### 锁定语句

S锁

```mysql
SELECT ... LOCK IN SHARE MODE;
```

别的事务可以获取S锁，但是不能获取X锁，除非S锁被释放

X锁

```mysql
SELECT ... FOR UPDATE;
```



### 写操作

DELETE UPDATE : 先在B+树定位，再获取X锁

INSERT：受隐式锁保护



## 多粒度锁

给记录加的锁叫行锁

给表加的锁是表锁

因为给表加S或者X锁的时候，要确认表没记录没有S或X锁

所以设计了 意向锁（Intention Lock）

- 意向共享锁（Intention Shared Lock）：简称IS锁，当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁
- 意向独占锁（Intention Exclusive Lock）： 简称IX锁，当事务准备在某条记录上加X锁时，需要先在表级别加一个X锁

> IS和IX锁是兼容的，因为他们是用来给表加S或X锁才会用到的

不建议手动获取表级别锁，会降低并发能力，建议用行锁

```mysql
LOCK TABLES t READ;  // 表S锁
LOCK TABLES T WRITE: // 表x锁
```

### 表级别的AUTO—INC锁 自增锁

字段声明了 AUTO_INCREMENT

实现方式：

1. 采用AUTO-INC锁 （innodb_autoinc_lock_mode = 0）

   在执行插入语句时，加入一个表级别的自增锁，然后为每条待插入的记录分配自增值。语句执行结束后释放掉锁

2. 采用一个轻量级的锁（innodb_autoinc_lock_mode = 2），在插入是获取自增值，就释放掉锁，不等sql执行完。会导致不同事务批量插入的自增键不连续



## InnoDB中的行级锁

数据准备

![image-20210105141834846](/assets/img/image-20210105141834846.png)

#### Record Lock 记录锁

LOCK_REC_NOT_GAP

![image-20210105142019275](/assets/img/image-20210105142019275.png)

记录锁分为S锁和X锁



#### Gap Lock 间隙锁

 幻读解决方案

1. MVCC
2. 加锁

当用加锁方案解决时，有个问题，就是事务在第一次执行读取操作时，那些欢迎记录还不存在，无法加记录锁

这时就需要gap锁，防止插入幻影记录

![image-20210105142635712](/assets/img/image-20210105142635712.png)

如果是最后一条记录 ，会在Supermum记录加gap锁，锁定(20 , +无穷)的新记录，阻塞插入



#### next_key 锁

记录锁和gap锁组合，既锁住某条记录，又锁住之后的间隙

![image-20210105143147777](/assets/img/image-20210105143147777.png)



#### Insert Intention Lock 插入意向锁

一个事务在插入一条记录时，需要判断插入位置是否已被别的事务加了gap锁，如果有的话，需要等待。等待的时候的锁结构就是插入意向锁

![image-20210105143352133](/assets/img/image-20210105143352133.png)



#### 隐式锁

一个事务对新插入的记录可以不显示地加锁，但是有trx_id存在（记录最后修改该记录的事务id），相当于一个隐式锁。

当其他事务想要对新插入记录添加S或X锁的时候，会判断trx_id是否为当前活跃的事务，如果是的话，会为当前事务创建一个X锁，is_waiting=false ，自己也创建一个锁结构，is_waiting=true

二级索引的话，判断的是Page Header 的 Page_Max_Trx_ID属性



## 当前读 和 快照读

### 当前读:

　　select...lock in share mode (共享读锁)
　　select...for update
　　update , delete , insert

　　当前读, 读取的是最新版本, 并且**对读取的记录加锁, 阻塞其他事务同时改动相同**记录，避免出现安全问题。

　　例如，假设要update一条记录，但是另一个事务已经delete这条数据并且commit了，如果不加锁就会产生冲突。所以update的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。

### 当前读的实现方式：next-key锁(行记录锁+Gap间隙锁)

 　**间隙锁：**只有在Read Repeatable、Serializable隔离级别才有，就是锁定范围空间的数据，假设id有3,4,5，锁定id>3的数据，是指的4，5及**后面的数字都会被锁定，**因为此时如果不锁定没有的数据，例如当加入了新的数据id=6，就会出现幻读，间隙锁避免了幻读。

　　1. 对主键或唯一索引，如果当前读时，where条件全部精确命中(=或者in)，这种场景本身就不会出现幻读，所以只会加行记录锁。

　　2. 没有索引的列，当前读操作时，会加全表gap锁，生产环境要注意。

　　3. 非唯一索引列，如果where条件部分命中(>、<、like等)或者全未命中，则会加附近gap间隙锁。例如，某表数据如下，非唯一索引2,6,9,9,11,15。如下语句要操作非唯一索引列9的数据，gap锁将会锁定的列是(6,11]，该区间内无法插入数据。

 ![img](/assets/img/1394267-20190419210558267-1762386565.png)

　　 

 

### 快照读

　　单纯的select操作，**不包括**上述 select ... lock in share mode, select ... for update。　　　　

　　Read Committed隔离级别：每次select都生成一个快照读。

　　Read Repeatable隔离级别：**开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。**

 

快照读的实现方式：undo日志和多版本并发控制MVCC



## 死锁

不同事务由于互相持有对方需要的锁而导致事务都无法继续执行的情况称为死锁

死锁发生时，InnoDB会选择一个较小的事务进行回滚



## 锁总结

- 排它锁指的是，在某个事务获取数据的排它锁后，其他事务不能获取该数据的任何锁， **并不代表其他事务不能无锁读取该数据。**
  - 无锁
    - **select ... from**
  - 共享锁
    - **select ... lock in share mode**
  - 排它锁
    - **update**
    - **delete**
    - **insert**
    - **select ... for update**
- MySQL8.0 中，使用 FOR SHARE 替代了 LOCK IN SHARE MODE，但仍然支持 LOCK IN SHARE MODE； 虽然是等价的，但是 FOR SHARE 支持 NOWAIT 、 SKIP LOCKED 等，配合自旋，可以实现高效的等待队列。

### 乐观锁 & 悲观锁

> 不管是什么锁都需要增加，需加失败重试

#### 乐观锁

乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户信息，让用户决定如何去做。乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。

- 通过版本号来进行更新的操作属于乐观锁

  ```
  select id,name,version from table;
  update table set name = xxx, version = version + 1 where id = xxx and version = xxx
  ```

#### 悲观锁

当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。

> 共享锁 & 排它锁都是悲观锁的具象实现

- 显示地控制行或表锁属于悲观锁