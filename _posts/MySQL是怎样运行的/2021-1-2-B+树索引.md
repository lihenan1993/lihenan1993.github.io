---
title: B+树索引
category: MySQL是怎样运行的
typora-root-url: ../../
---

# B+树索引

## 没有索引的检索

![image-20210102132419055](/assets/img/image-20210102132419055.png)



页之间是双向链表连接，物理上可能不在一起。

多页内查找过程：

1. 从第一页开始，遍历双向链表
2. 每页内按照槽进行二分查找遍历

很耗时，效率低



## 页分裂

通过移动记录来保持

下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值

称为 **页分裂**

> 也就是说，页与页之间是有序的，根据索引

## 目录项

由索引和页号组成

![image-20210102185433651](/assets/img/image-20210102185433651.png)



## 目录页

![image-20210102181943364](/assets/img/image-20210102181943364.png)

record_type = 1 目录项记录

record_type = 0 普通记录

记录头信息 min_rec_flag = 1 目录项



## 多级目录页形成 B+树

![image-20210102182328517](/assets/img/image-20210102182328517.png)

查找过程：

根据二分法逐级查找目录项，最后找到数据页



特点：

1. 所有的叶子节点都是数据页
2. 中间路径为目录页
3. 有序
4. 层级一般不会很多（4左右） 



## B+树

![image-20210102182830803](/assets/img/image-20210102182830803.png)

### 聚簇索引

具备以下两个特点的B+树，称为聚簇索引

1. 使用记录主键值的大小进行记录和页的排序
   1. 页内记录按照主键大小排序分成很多组
   2. 每个组中主键值最大的记录在页内的偏移量会被当作槽依次存放在页目录中
   3. 各个页按主键大小排成一个双向链表
2. B+树的叶子节点存储的是**完整的用户记录**
   1. 完整的用户记录：这个记录中存储了所有列的值，包括隐藏列

InnoDB存储引擎会自动创建聚簇索引，聚簇索引就是数据的存储方式



InnoDB会自动为主键建立索引

没有主键，用不允许为NULL的UNIQUE列建立索引

没有的话，InnoDB自动添加一个自增主键



## 二级索引  ，辅助索引

以非主键的列建立索引

特点：

1. B+树的叶子节点存储的并不是完整的用户记录，而是 **索引列 + 主键** 的值
2. 根据索引列值排序，相同的话，根据主键排序
3. 查到相应的主键后，还需要去聚簇索引回表查询具体的用户记录

下表使用C2列建立的二级索引，这个图其实是不准确的，目录项中还应该有主键

> 因此，其实二级索引，就是索引列和主键建立的联合索引
>
> 即使索引列是UNIQUE声明的，但是存在NULL和MVVC，因此目录项还是需要主键

![image-20210102185037242](/assets/img/image-20210102185037242.png)

正确的图

![image-20210102194958671](/assets/img/image-20210102194958671.png)



## 联合索引

同时以多个列的大小作为排序规则，同时为多个列建立索引

比如以c2 和 c3 建立联合索引

特点：

1. 只是一个B+树
2. 先比较c2 ，当c2相同时候，按c3顺序排序
3. 叶子节点只有 多个索引列的值和主键

联合索引就是一种特殊的二级索引



## B+树索引的注意事项

建立过程：

1. 表创建的时候，就会有创建一个根节点页面
2. 根节点页面存满后，升级为目录页（根节点页面页号不变），原来根节点的记录存入新的页A，多余的记录发生页分裂，存入新的页B，C。。。
3. 根节点页面页号，会被记录在一个特殊的地方



## MyISAM索引

叶子节点存的是主键和行号，还需要回表再查一次。

所以索引和数据是分离的。



## 创建索引

```mysql
1.添加PRIMARY KEY(主键索引)

alter table `table_name` add primary key(`column`);

2.添加UNIQUE(唯一索引)

alter table `table_name` add unique(`column`);

3.添加普通索引

alter table `table_name` add index index_name(`column`);

4.添加全文索引

alter table `table_name` add fulltext(`column`);

5.添加多列索引

alter table `table_name` add index index_name(`column1`,`column2`,`column3`);
```



# B+树索引的使用

```mysql
CREATE TABLE single_table{
	id INT NOT NULL AUTO_INCREMENT,
	key1 VARCHAR(100),
	key2 INT,
	key3 VARCHAR(100),
	key_part1 VARCHAR(100),
	key_part2 VARCHAR(100),
	key_part3 VARCHAR(100),
	common_field VARCHAR(100),
	PRIMARY KEY (id),
	KEY idx_key1 (key1),
	UNIQUE KEY uk_key2 (key2),
	KEY idx_key3 (key3),
	KEY idx_key_part(key_part1, key_part2, key_part3)
} Engine=InnoDB CHARSET=utf8
```



## 索引的代价

1. 占用空间
2. 增删改操作，都需要修改B+树索引，需要额外的时间调整记录排序，进行页分裂，页回收等操作
3. 评估使用哪个索引执行查询计划，索引多会加大成本分析耗时



## 扫描区间和边界条件

```mysql
SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79)
```

因为有uk_key2索引

| 扫描区间     | 边界条件                  |
| ------------ | ------------------------- |
| [1438, 1438] | key2 IN (1438)            |
| [6328, 6328] | key2 IN (6328)            |
| [38, 79]     | key2 >= 38 AND key2 <= 79 |

![image-20210102210849544](/assets/img/image-20210102210849544.png)

注意：

1. 分析扫描区间是关键

2. 字符串比较大小是 **依次比较每个字符的大小** 

   所以 如果是 LIKE 'a%' 这种条件，扫描区间为 ['a','b')

   而 LIKE '%a' ，扫描区间就是全表了



## 复杂搜索条件中提取出正确的扫描区间



### 所有搜索条件都可以生成合适的扫描区间的情况

```mysql
SELECT * FROM single_table WHERE key2 > 100 AND key2 > 200
```

区间 [200, +无穷]

```mysql
SELECT * FROM single_table WHERE key2 > 100 OR key2 > 200
```

区间 [100, +无穷]





### 有的搜索条件不能生成合适的扫描区间的情况

```mysql
SELECT * FROM single_table WHERE key2 > 100 AND common_field = 'abc';
```

因为 common_field 和 key2 没有联合索引 ， common_field 也没有索引， 所以边界条件是 key 2 > 100 AND TRUE    

即 key2  [100, +无穷]

```mysql
SELECT * FROM single_table WHERE key2 > 100 OR common_field = 'abc';
```

key 2 > 100 OR TRUE

就是全表扫描了



### 从复杂的搜索条件中找出扫描区间

```mysql
WHERE
(key1 > 'xyz' AND key2 = 748) OR
(key1 < 'abc' AND key1 > 'lmn') OR
(key1 LIKE '%suf' AND key1 > 'zzz' AND (key2 < 8000 OR common_field ='abc'))
```

分析方式：

1. 把用不到索引的条件 简写为 TRUE
2. 合并区间



- 假设使用idx_key1执行查询

  那么 key2 和 common_file 都是 TRUE

  ```mysql
  WHERE
  (key1 > 'xyz' AND TRUE) OR
  (key1 < 'abc' AND key1 > 'lmn') OR
  (key1 LIKE '%suf' AND key1 > 'zzz' AND (TRUE OR TRUE))
  ```

  ```mysql
  key1 > 'xyz'
  ```

- 假设使用uk_key2执行查询

  ```mysql
  WHERE
  (TRUE AND key2 = 748) OR
  (TRUE AND TRUE) OR
  (key2 < 8000 OR TRUE)
  ```

  OR
  (TRUE AND TRUE)

  所以区间是 正负无穷 ，只能全表扫描

  

#### 索引条件下推

**“索引条件下推”，称为** Index Condition Pushdown (ICP)

mysql5.6增加了一个针对索引性能的优化方案，可以利用索引把本来由服务层做的过滤操作下推到引擎层完成，较少了数据的传输，提升索引效率。

假设存在一张表结构如下：

```mysql
create table people
(
 zipcode varchar(11) null,
 lastname varchar(20) null,
 address varchar(20) null
);

create index people_zipcode_lastname_address_index
 on people (zipcode, lastname, address);
```

以下面这条SQL为例，当没有索引条件下推优化的时候，由于联合索引只能命中`zipcode`(最左原则+模糊匹配字符串不支持索引过滤)，导致引擎层只能将`zipcode='95054'`的数据全部取出来交给服务器层再做两个`LIKE`过滤。而有了联合索引过滤，这个条件过滤操作被下推到引擎层直接执行，优化性能。

```mysql
SELECT * FROM people
  WHERE zipcode='95054'
  AND lastname LIKE '%etrunia%'
  AND address LIKE '%Main Street%';
```



### 使用联合索引执行查询时对应的扫描区间