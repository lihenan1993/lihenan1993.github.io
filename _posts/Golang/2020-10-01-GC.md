---
title: GC
category: Golang
typora-root-url: ../..
---



### 什么是GC

`GC`，全称 `Garbage Collection`，即垃圾回收，是一种自动内存管理的机制。

- 降低程序员编程的负担，但是也会降低程序执行的效率。

- 提供一些特定的API，供特殊情况下的调优。



通常，垃圾回收器的执行过程被划分为两个半独立的组件：

- 赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上进行操作。
- 回收器（Collector）：负责执行垃圾回收的代码。



### 什么是根对象

根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：

1. 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
2. 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
3. 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。



### Golang的GC

Go 的 GC 目前使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。

没用对象整理的原因：

对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但 Go 运行时的分配算法基于 tcmalloc，基本上没有碎片问题。

无分代原因：

分代 GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当 goroutine 死亡后栈也会被直接回收，不需要 GC 的参与，进而分代假设并没有带来直接优势。



### 触发时机

1. 主动触发

   runtime.GC ， 阻塞式地等待当前GC运行完毕

2. 被动触发
   1. 两分钟没产生GC
   2. 使用步调(Pacing)算法，其核心思想是控制内存增长的比例。步调算法还需要考虑 CPU 利用率的问题，不应该让垃圾回收器占用过多的 CPU



### GC流程

| OFF状态                              |        |         | 如果不是OFF状态，说明上一轮GC未完成，则新一轮GC不可用     此时指针修改，就直接是内存修改 |
| ------------------------------------ | ------ | ------- | ------------------------------------------------------------ |
| 堆（heap）扫描<br />SweepTermination | 写屏障 | 极短STW | 清扫终止阶段，收集根对象，为下一个阶段的并发标记做准备工作   |
| 标记 Mark                            | 写屏障 |         | 扫描标记阶段，与赋值器并发执行                               |
| 标记终止 <br />MarkTermination       | 写屏障 | STW     | 重新扫描写屏障期间发生的指针变更，再进行三色标记             |
| 清除 Sweep                           |        |         | 内存清扫阶段，将需要回收的内存归还到堆中     为下一个GC周期做准备 |
| OFF状态                              |        |         | 内存归还阶段，将过多的内存归还给操作系统                     |

一轮完整的 GC，总是从 Off，如果不是 Off 状态，则代表上一轮GC还未完成，如果这时修改指针的值，是直接修改的。

heap scan: 收集根对象，该阶段会开启写屏障(Write Barrier)。

Mark: 标记对象，直到标记完所有根对象和根对象可达对象。此时写屏障会记录所有指针的更改(通过 mutator)。

Mark Termination: 重新扫描部分全局变量和发生更改的堆变量，完成标记，该阶段会STW(Stop The World)，**也是 gc 时造成 go 程序停顿的主要阶段。**

Sweep: 根据需要并发的回收未标记的对象。

### 三色标记

标记阶段使用的方法是 三色标记法

三色标记法是传统标记-清除法的优化，增加了一种中间状态，即灰色对象，以减少STW时间

#### 三种颜色

三色标记将对象分为白色、灰色、黑色三种：

- 白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。
- 灰色对象（波面）：已被回收器访问到的对象，但回收器需要对灰色对象中的指针进行扫描，因为他们可能还指向白色对象。
- 黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。

![三色标记法全貌](D:\work\learn\lihenan1993.github.io\assets\img\gc-blueprint-1607523258132.png)

#### 过程

三色标记的主要过程即：

1. 开始时所有对象为白色
2. 将所有**根对象**标记为灰色，放入队列
3. 遍历灰色对象，将其标记为黑色，并将他们引用的对象标记为灰色，放入队列
4. 重复步骤 *3* 持续遍历灰色对象，直至队列为空
5. 此时只剩下黑色对象和白色对象，白色对象即为下一步需要清除的对象

### STW 万物静止

STW 在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题，从而不可避免的需要停止赋值器进一步操作对象图。

在这个过程中整个用户代码被停止或者放缓执行， `STW` 越长，对用户代码造成的影响（例如延迟）就越大。



传统的标记-清除算法，为了防止在标记过程中，对象引用发生变化，导致清除仍在使用的对象，需要 STW(Stop The World)，这会造成程序的停顿。

在三色标记的过程中，由于引入了灰色对象这一中间状态，标记过程和用户的 golang 代码中可以并发执行，不需要 STW，这极大的减少了应用的停顿时间。



三色标记具体如何避免在标记过程中对象应用的改变呢，这里用到了写屏障(Write Barrier)。

### 清除的难点

并发标记清除中面临的一个根本问题就是如何保证标记与清除过程的正确性。

垃圾回收器的正确性体现在：**不应出现对象的丢失，也不应错误的回收还不需要回收的对象。**

可以证明，**当以下两个条件同时满足时**会破坏垃圾回收器的正确性：

- **条件 1**: 赋值器修改对象图，导致某一黑色对象引用白色对象； （图2）
  - 注意：黑色对象肯定是通过灰色对象引用的白色对象，否则该白色对象应该已经被标记为灰色了
- **条件 2**: 从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏。 （图3）
  - 即条件1 灰到白 的引用路径被破坏

> 简单来说就是，黑色对象通过一灰色对象引用了白色对象，且该灰色对象引用白色对象的路径被破坏。

只要能够避免其中任何一个条件，则不会出现对象丢失的情况，因为：

- 如果条件 1 被避免，则所有白色对象均被灰色对象引用，没有白色对象会被遗漏；
- 如果条件 2 被避免，即便白色对象的指针被写入到黑色对象中，但从灰色对象出发，总存在一条没有访问过的路径，从而找到到达白色对象的路径，白色对象最终不会被遗漏。

![gc-mutator](D:\work\learn\lihenan1993.github.io\assets\img\gc-mutator.png)

- 初始状态：假设某个黑色对象 C 指向某个灰色对象 A ，而 A 指向白色对象 B；
- `C.ref3 = C.ref2.ref1`：赋值器并发地将黑色对象 C 指向（ref3）了白色对象 B；
- `A.ref1 = nil`：移除灰色对象 A 对白色对象 B 的引用（ref2）；
- 最终状态：在继续扫描的过程中，白色对象 B 永远不会被标记为黑色对象了（回收器不会重新扫描黑色对象），进而对象 B 被错误地回收。

### 混合写屏障

在 GC 的流程中，堆扫描这一步骤，启用了混合写屏障。混合写屏障的主要思想，是在标记的过程中，通过写屏障记录发生变化的指针，然后在 标记终止 过程中，重新进行扫描，因为在这一步骤会 STW，所以在这一步骤完成后的白色对象，不会再被引用，可以直接清除。

Go 在 1.8 的时候为了简化 GC 的流程，同时减少标记终止阶段的重扫成本，将 Dijkstra 插入屏障和 Yuasa 删除屏障进行混合，形成混合写屏障。该屏障提出时的基本思想是：**对正在被覆盖的对象进行着色，且如果当前栈未扫描完成，则同样对指针进行着色。**



### 如果内存分配速度超过了标记清除的速度怎么办？

当存在新的内存分配时，会暂停分配内存过快的那些 goroutine，并将其转去执行一些辅助标记（Mark Assist）的工作，从而达到放缓继续分配、辅助 GC 的标记工作的目的。

### GC 关注的指标有哪些？

Go 的 GC 被设计为成比例触发、大部分工作与赋值器并发、不分代、无内存移动且会主动向操作系统归还申请的内存。因此最主要关注的、能够影响赋值器的性能指标有：

- CPU 利用率：通过回收占用的 CPU 时间与其它 CPU 时间的百分比来描述。
- GC 停顿时间：回收器会造成多长时间的停顿？STW
- GC 停顿频率：回收器造成的停顿频率是怎样的？STW
- GC 可扩展性：当堆内存变大时，垃圾回收器的性能如何？

### GC调优

针对对于STW或者资源（内存、CPU）分配极其敏感的应用

当我们谈论 GC 调优时，通常是指减少用户代码对 GC 产生的压力，这一方面包含了减少用户代码分配内存的数量（即对程序的代码行为进行调优），另一方面包含了最小化 Go 的 GC 对 CPU 的使用率（即调整 GOGC）。

方式：

1. 控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率。
2. 减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。
3. 需要时，增大 GOGC 的值，降低 GC 的运行频率。

工具：

```
go tool pprof 
go tool trace
```

### GC支持与不支持的语言

从原理上而言，所有的语言都能够自行实现 GC。从语言诞生之初就提供 GC 的语言，例如：

- Python
- JavaScript
- Java
- Objective-C
- Swift

而不以 GC 为目标，被直接设计为手动管理内存、但可以自行实现 GC 的语言有：

- C
- C++

也有一些语言可以在编译期，依靠编译器插入清理代码的方式，实现精准的清理，例如：

- Rust