---
title: GC
category: Golang
typora-root-url: ../..
---



### 什么是GC

`GC`，全称 `Garbage Collection`，即垃圾回收，是一种自动内存管理的机制。

- 降低程序员编程的负担，但是也会降低程序执行的效率。

- 提供一些特定的API，供特殊情况下的调优。



通常，垃圾回收器的执行过程被划分为两个半独立的组件：

- 赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上进行操作。
- 回收器（Collector）：负责执行垃圾回收的代码。



### 什么是根对象

根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：

1. 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
2. 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
3. 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。



### Golang的GC

Go 的 GC 目前使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清除算法。

没用对象整理的原因：

对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但 Go 运行时的分配算法基于 tcmalloc，基本上没有碎片问题。

无分代原因：

分代 GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当 goroutine 死亡后栈也会被直接回收，不需要 GC 的参与，进而分代假设并没有带来直接优势。



### 触发时机

1. 主动触发

   runtime.GC ， 阻塞式地等待当前GC运行完毕

2. 被动触发
   1. 两分钟没产生GC
   2. 使用步调(Pacing)算法，其核心思想是控制内存增长的比例。步调算法还需要考虑 CPU 利用率的问题，不应该让垃圾回收器占用过多的 CPU



### GC流程 Go v1.14

准备阶段：

完成上一轮GC未完成的清扫工作

为每个P创建一个 标记工作(mark worker)协程， 这些协程创建后很快休眠等待到标记阶段（第二阶段）得到调度

| 第一阶段，GC开始       | 开启混合写屏障 | STW  | gphase = _GCMark<br />收集根对象并加入标记队列               |
| ---------------------- | -------------- | ---- | ------------------------------------------------------------ |
| 第二阶段，标记阶段     | 混合写屏障保护 |      | 进行并发的三色标记<br />如果用户代码修改对象，那么会触发混合写屏障，将对象标记为灰色，并加入写屏障缓冲区的队列中<br />如果新建对象，被标记为黑色 |
| 第三阶段，标记终止阶段 | 关闭混合写屏障 | STW  | gphase = _GCMarkTermination<br />停止后台 标记工作协程 和 辅助标记协程 <br />gphase = _GCOFF<br />关闭混合写屏障 |
| 第四阶段，清扫阶段     |                |      | 用于清扫的协程bgsweep，执行清扫任务 。 协程负债执行清扫工作。gphase = _GCOFF后新创建对象就是白色了。 |



### 三色标记

标记阶段使用的方法是 三色标记法

三色标记法是传统标记-清除法的优化，增加了一种中间状态，即灰色对象，以减少STW时间

#### 三种颜色

三色标记将对象分为白色、灰色、黑色三种：

- 白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。
- 灰色对象（波面）：已被回收器访问到的对象，但回收器需要对灰色对象中的指针进行扫描，因为他们可能还指向白色对象。
- 黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。

![三色标记法全貌](D:\work\learn\lihenan1993.github.io\assets\img\gc-blueprint-1607523258132.png)

#### 过程

三色标记的主要过程即：

1. 开始时所有对象为白色
2. 将所有**根对象**标记为灰色，放入队列
3. 遍历灰色对象，将其标记为黑色，并将他们引用的对象标记为灰色，放入队列
4. 重复步骤 *3* 持续遍历灰色对象，直至队列为空
5. 此时只剩下黑色对象和白色对象，白色对象即为下一步需要清除的对象



### Golang中GC的三色标记

1. 着为灰色对应的操作就是把指针对应的gcmarkBits标记位置为1并加入工作队列；
2. 着为黑色对应的操作就是把指针对应的gcmarkBits标记位置为1。
3. 白色对象就是那些gcMarkBits中标记为0的对象。



### STW 万物静止

STW 在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题，从而不可避免的需要停止赋值器进一步操作对象图。

在这个过程中整个用户代码被停止或者放缓执行， `STW` 越长，对用户代码造成的影响（例如延迟）就越大。



传统的标记-清除算法，为了防止在标记过程中，对象引用发生变化，导致清除仍在使用的对象，需要 STW(Stop The World)，这会造成程序的停顿。

在三色标记的过程中，由于引入了灰色对象这一中间状态，标记过程和用户的 golang 代码中可以并发执行，不需要 STW，这极大的减少了应用的停顿时间。



三色标记具体如何避免在标记过程中对象应用的改变呢，这里用到了混合写屏障。

### 清除的难点

并发标记清除中面临的一个根本问题就是如何保证标记与清除过程的正确性。

垃圾回收器的正确性体现在：**不应出现对象的丢失，也不应错误的回收还不需要回收的对象。**

可以证明，**当以下两个条件同时满足时**会破坏垃圾回收器的正确性：

- **条件 1**: 赋值器修改对象图，导致某一黑色对象引用白色对象； （图2）
  - 注意：黑色对象肯定是通过灰色对象引用的白色对象，否则该白色对象应该已经被标记为灰色了
- **条件 2**: 从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏。 （图3）
  - 即条件1 灰到白 的引用路径被破坏

> 简单来说就是，黑色对象通过一灰色对象引用了白色对象，且该灰色对象引用白色对象的路径被破坏。

只要能够避免其中任何一个条件，则不会出现对象丢失的情况，因为：

- 如果条件 1 被避免，则所有白色对象均被灰色对象引用，没有白色对象会被遗漏；
- 如果条件 2 被避免，即便白色对象的指针被写入到黑色对象中，但从灰色对象出发，总存在一条没有访问过的路径，从而找到到达白色对象的路径，白色对象最终不会被遗漏。

![gc-mutator](D:\work\learn\lihenan1993.github.io\assets\img\gc-mutator.png)

- 初始状态：假设某个黑色对象 C 指向某个灰色对象 A ，而 A 指向白色对象 B；
- `C.ref3 = C.ref2.ref1`：赋值器并发地将黑色对象 C 指向（ref3）了白色对象 B；
- `A.ref1 = nil`：移除灰色对象 A 对白色对象 B 的引用（ref2）；
- 最终状态：在继续扫描的过程中，白色对象 B 永远不会被标记为黑色对象了（回收器不会重新扫描黑色对象），进而对象 B 被错误地回收。

### 混合写屏障

#### 三色不变式

- 强三色不变式

  不存在黑色对象引用到白色对象的指针

  ![img](/assets/img/9e3dc92eb1e4641ff904d17130eb6d32.jpg)

- 弱三色不变式

  所有被黑色对象引用的白色对象都处于灰色保护状态（灰色对象可达白色对象，或者链路可达）。

  ![img](/assets/img/301fa8dbb562ebccde43c4270ed83d22.jpg)

#### 屏障

1. 内存屏障只是对应一段特殊的代码
2. 内存屏障这段代码在编译期间生成
3. 内存屏障本质上在运行期间拦截内存写操作，相当于一个 hook 调用



#### 插入屏障

使得满足强三色不变性

1. 具体操作：

   在A对象引用B对象的时候，B对象被标记为灰色（新的引用被标记为灰色）

   满足强三色不变性，因为黑色引用的白色对象被标记为灰色对象

2. 操作对象，堆空间对象

   栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在**栈空间的对象操作中不使用**. 而仅仅使用在堆空间对象的操作中.



缺点：

1. 结束时需要STW来重新扫描栈，大约需要10 - 100ms

##### 插入屏障问题

1. 如图，新添加一个对象1到对象9的引用，因为栈不开启，插入屏障，所以对象9会被错误的回收

![image-20210106170845278](/assets/img/image-20210106170845278.png)

2. 所以，当标记结束后，需要开启STW，将栈上的对象都改为白色，重新标记（re—scan）

   ![image-20210106171105520](/assets/img/image-20210106171105520.png)

3. 停止STW

     ![image-20210106171228632](/assets/img/image-20210106171228632.png)

4. 删除白色

   ![image-20210106171247825](/assets/img/image-20210106171247825.png)



#### 删除屏障

1. 具体操作

   被删除的对象，如果自身为灰色或者白色，那么被标记为灰色

   满足：弱三色不变式（保护灰色对象到白色对象的路径不会断）
   
   栈是开启**删除屏障**
   
   堆是**插入屏障**

##### 删除屏障过程

![image-20210106171930683](/assets/img/image-20210106171930683.png)

![image-20210106172001869](/assets/img/image-20210106172001869.png)

最后 没用的对象5 以及对象2和对象3都没有被回收

![image-20210106172050696](/assets/img/image-20210106172050696.png)



优点：不用STW重新扫描栈了

缺点：回收精度低，一个对象即使被删除了最后一个指向它的指针也依然可以存活一轮，在下一轮GC被清理掉



### 混合写屏障机制

Go V1.8版本引入了混合写屏障机制（hybrid write barrier），只需要在第二阶段-标记阶段开始的时候，并发扫描各个goroutine的栈，使其对象变黑，避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。

> 混合写屏障满足的是 弱三色不变式

过程：

1. GC开始将栈上的对象全部扫描并标记为黑色 （不再二次重复扫描）
2. GC期间，任何在栈上**新创建**的对象，均为黑色
3. **被删除**的对象被标记为灰色（沿用删除屏障）
4. **被添加**的对象标记为灰色（插入屏障）
5. 相关节点记录到写屏障缓冲区中，按需flush到工作队列

> 有了以上条件，只需要在堆上开启混合写屏障，栈上不需要开启任何屏障，也不需要二次重复扫描栈。
>
> 有些栈上对象可能延迟删除，不过没事，栈上对象比较小

##### 混合写屏障流程

1. GC开始，优先扫描栈，栈全部标记完成，栈上不开启屏障

   ![image-20210106172757853](/assets/img/image-20210106172757853.png)





### 并发GC如何缓解内存分配压力

**为了避免GC执行过程中，内存分配压力过大**，还实现了GC Assist机制，包括“**辅助标记**”和“**辅助清扫**”。
如果**协程要分配内存，而GC标记工作尚未完成**，它就要负担一部分标记工作，要申请的内存越大，对应要负担的标记任务就越多，这是一种借贷偿还机制：
当前G要申请的内存大小对应它所负担的债务多少，债务越多，就需要做越多的标记工作来偿还债务。

### 如何控制GC的CPU使用率

GC默认的CPU目标使用率为25%，在GC执行的初始化阶段，会根据当前CPU核数乘以CPU目标使用率来计算需要启动的mark worker数量。

为了应对计算结果不为整数的情况，会对该结果进行rounding（+0.5）。但是又怕这样的rounding会和目标使用率出现显著偏差，所以在mark worker中引入了不同的工作模式:
(1)**Dedicated**模式的worker会执行标记任务直到被抢占；
(2)**Fractional**模式的worker除了被抢占外，还可以在达到目标使用率时主动让出。



### GC 关注的指标有哪些？

Go 的 GC 被设计为成比例触发、大部分工作与赋值器并发、不分代、无内存移动且会主动向操作系统归还申请的内存。因此最主要关注的、能够影响赋值器的性能指标有：

- CPU 利用率：通过回收占用的 CPU 时间与其它 CPU 时间的百分比来描述。
- GC 停顿时间：回收器会造成多长时间的停顿？STW
- GC 停顿频率：回收器造成的停顿频率是怎样的？STW
- GC 可扩展性：当堆内存变大时，垃圾回收器的性能如何？

### GC调优

针对对于STW或者资源（内存、CPU）分配极其敏感的应用

当我们谈论 GC 调优时，通常是指减少用户代码对 GC 产生的压力，这一方面包含了减少用户代码分配内存的数量（即对程序的代码行为进行调优），另一方面包含了最小化 Go 的 GC 对 CPU 的使用率（即调整 GOGC）。

方式：

1. 控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率。
2. 减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。
3. 需要时，增大 GOGC 的值，降低 GC 的运行频率。

工具：

```
go tool pprof 
go tool trace
```

### GC支持与不支持的语言

从原理上而言，所有的语言都能够自行实现 GC。从语言诞生之初就提供 GC 的语言，例如：

- Python 引用计数 + 分代回收
- JavaScript 标记清除
- Java
- Objective-C
- Swift

而不以 GC 为目标，被直接设计为手动管理内存、但可以自行实现 GC 的语言有：

- C
- C++

也有一些语言可以在编译期，依靠编译器插入清理代码的方式，实现精准的清理，例如：

- Rust

