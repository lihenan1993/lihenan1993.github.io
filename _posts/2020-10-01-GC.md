---
title: GC
category: Golang
---



### 什么是GC

`GC`，全称 `Garbage Collection`，即垃圾回收，是一种自动内存管理的机制。

- 降低程序员变成的负担，但是也会降低程序执行的效率。

- 提供一些特定的API，供特殊情况下的调优。



通常，垃圾回收器的执行过程被划分为两个半独立的组件：

- 赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上进行操作。
- 回收器（Collector）：负责执行垃圾回收的代码。



### 什么是根对象

根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：

1. 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
2. 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
3. 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。



### Golang的GC

Go 的 GC 目前使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。

没用对象整理的原因：

对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但 Go 运行时的分配算法基于 tcmalloc，基本上没有碎片问题。

无分代原因：

分代 GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当 goroutine 死亡后栈也会被直接回收，不需要 GC 的参与，进而分代假设并没有带来直接优势。



### GC流程

| OFF状态                   |        |         | 如果不是OFF状态，说明上一轮GC未完成，则新一轮GC不可用     此时指针修改，就直接是内存修改 |
| ------------------------- | ------ | ------- | ------------------------------------------------------------ |
| 堆（heap）扫描            | 写屏障 | 极短STW | 收集根对象                                                   |
| 标记 Mark                 | 写屏障 |         | 多协程进行标记                                               |
| 标记终止 Mark Termination | 写屏障 | STW     | 重新扫描写屏障期间发生的指针变更，再进行三色标记             |
| 清除 Sweep                |        |         | 根据需要回收未标记的对象     为下一个GC周期做准备            |
| OFF状态                   |        |         | 重新回归OFF状态                                              |

一轮完整的 GC，总是从 Off，如果不是 Off 状态，则代表上一轮GC还未完成，如果这时修改指针的值，是直接修改的。

heap scan: 收集根对象，该阶段会开启写屏障(Write Barrier)。

Mark: 标记对象，直到标记完所有根对象和根对象可达对象。此时写屏障会记录所有指针的更改(通过 mutator)。

Mark Termination: 重新扫描部分全局变量和发生更改的堆变量，完成标记，该阶段会STW(Stop The World)，**也是 gc 时造成 go 程序停顿的主要阶段。**

Sweep: 根据需要并发的回收未标记的对象。

### 三色标记

标记阶段使用的方法是 三色标记法

三色标记法是传统标记-清除法的优化，增加了一种中间状态，即灰色对象，以减少STW时间

#### 三种颜色

三色标记将对象分为白色、灰色、黑色三种：

- 白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。
- 灰色对象（波面）：已被回收器访问到的对象，但回收器需要对灰色对象中的指针进行扫描，因为他们可能还指向白色对象。
- 黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。

![三色标记法全貌](D:\work\learn\lihenan1993.github.io\assets\img\gc-blueprint-1607523258132.png)

#### 过程

三色标记的主要过程即：

1. 开始时所有对象为白色
2. 将所有**根对象**标记为灰色，放入队列
3. 遍历灰色对象，将其标记为黑色，并将他们引用的对象标记为灰色，放入队列
4. 重复步骤 *3* 持续遍历灰色对象，直至队列为空
5. 此时只剩下黑色对象和白色对象，白色对象即为下一步需要清除的对象

### STW 万物静止

STW 在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题，从而不可避免的需要停止赋值器进一步操作对象图。

在这个过程中整个用户代码被停止或者放缓执行， `STW` 越长，对用户代码造成的影响（例如延迟）就越大。



传统的标记-清除算法，为了防止在标记过程中，对象引用发生变化，导致清除仍在使用的对象，需要 STW(Stop The World)，这会造成程序的停顿。

在三色标记的过程中，由于引入了灰色对象这一中间状态，标记过程和用户的 golang 代码中可以并发执行，不需要 STW，这极大的减少了应用的停顿时间。



三色标记具体如何避免在标记过程中对象应用的改变呢，这里用到了写屏障(Write Barrier)。

### 写屏障

在 GC 的流程中，堆扫描这一步骤，启用了写屏障。写屏障的主要思想，是在标记的过程中，通过写屏障记录发生变化的指针，然后在 标记终止 过程中，重新进行扫描，因为在这一步骤会 STW，所以在这一步骤完成后的白色对象，不会再被引用，可以直接清除。关于写屏障具体原理和实现，这里不再展开。