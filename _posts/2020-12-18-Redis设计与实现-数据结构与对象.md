---
title: 数据结构与对象
category: Redis设计与实现
typora-root-url: ..
---

# String - SDS

redis里面，C字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如打印日志



## 什么是SDS

redis中String键和值用的是 简单动态字符串(simple dynamic string, SDS)

![image-20201218214106744](/assets/img/image-20201218214106744.png)

```c
struct sdshdr {
    // 记录buf数组中已使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;
    // 未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
}
```



## C 字符串和 SDS 之间的区别

| C 字符串                                             | SDS                                                  |
| :--------------------------------------------------- | :--------------------------------------------------- |
| 获取字符串长度的复杂度为 O(N) 。                     | 获取字符串长度的复杂度为 O(1) 。                     |
| API 是不安全的，可能会造成缓冲区溢出。               | API 是安全的，不会造成缓冲区溢出。                   |
| 修改字符串长度 `N` 次必然需要执行 `N` 次内存重分配。 | 修改字符串长度 `N` 次最多需要执行 `N` 次内存重分配。 |
| 只能保存文本数据。                                   | 可以保存文本或者二进制数据。                         |
| 可以使用所有 `<string.h>` 库中的函数。               | 可以使用一部分 `<string.h>` 库中的函数。             |



## 优点

1. 扩容时候，不会造成缓冲区溢出
2. 减少修改字符串时候内存重分配次数
   1. 空间预分配， 修改后len小于1M，则预分配的free等于len ，最多为1M
   2. 惰性空间释放，缩短时候修改len和free，不是立即释放
3. 二进制安全，因为用的len ,而不是C中'\0'作为结束标志
4. 兼容部分C的函数，因为保留了结尾的'\0' 



# List - 链表

当list元素数量多，或者元素是比较长的字符串，redis使用链表作为list的底层实现

```c
typedef struct listNode {
	struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;

typedef struct list {
    listNode *head;
    listNode *tial;
    unsigned long len;
    // 节点值复制函数
    void *(*dup)(void *ptr);
    // 节点值释放函数
    void (*free)(void *ptr);
    // 节点值对比函数
    int (*match)(void *ptr, void *key);
} list;
```

![digraph {图 3-2    由 list 结构和 listNode 结构组成的链表}](/assets/img/graphviz-5f4d8b6177061ac52d0ae05ef357fceb52e9cb90.png)



### Redis 的链表实现的特性可以总结如下：

- 双端： 链表节点带有 `prev` 和 `next` 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。
- 无环： 表头节点的 `prev` 指针和表尾节点的 `next` 指针都指向 `NULL` ， 对链表的访问以 `NULL` 为终点。
- 带表头指针和表尾指针： 通过 `list` 结构的 `head` 指针和 `tail` 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。
- 带链表长度计数器： 程序使用 `list` 结构的 `len` 属性来对 `list` 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。
- 多态： 链表节点使用 `void*` 指针来保存节点值， 并且可以通过 `list` 结构的 `dup` 、 `free` 、 `match` 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。



# Hash - 哈希表

> - 什么是哈希表
>
>   把关键码值（key-value）通过散列函数，映射到表中一个位置来访问记录，以加快查找的速度。
>
> - 解决冲突的方法 
>
>   链表法和散列法（开放寻址和再散列）
>
> - 适用
>
>   “数量有限”但“不同索引数量极大”的一些数据，必需极高的访问效率同时又不想无端消耗太多的存储空间
>
> - 注意
>
>   查找时间与数据可散列的程度有关，最坏O(N)，最好O(1)

```c
// 字典
typedef struct dict {
    // 类型特定函数
    dictType *type;
    // 私有数据
    void *privdata;
    // 哈希表
    dictht ht[2];
    // rehash 索引
    // 当 rehash 不在进行时，值为 -1
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */
} dict;

// 哈希表
typedef struct dictht {
    // 哈希表数组
    dictEntry **table;
    // 哈希表大小
    unsigned long size;
    // 哈希表大小掩码，用于计算索引值
    // 总是等于 size - 1
    unsigned long sizemask;
    // 该哈希表已有节点的数量
    unsigned long used;
} dictht;

// 哈希表节点，链表法
typedef struct dictEntry {
    // 键
    void *key;
    // 值
    union {
        // 对象指针
        void *val;
        // 无符号64位整数
        uint64_t u64;
        // 有符号64位整数
        int64_t s64;
    } v;
    // 指向下个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```

![image-20201219133119437](/assets/img/image-20201219133119437.png)

- 散列算法

  murmurHash，优点即使输入的key有规律，算法扔能给出一个很好的随机分布性，并且算法的计算速度也非常快

- 解决键冲突

  链表法，哈希表节点中的next存有下一个哈希表节点的指针

- rehash

  1. 负载因子

     ```
     # 负载因子 = 哈希表已保存节点数量 / 哈希表大小
     load_factor = ht[0].used / ht[0].size
     ```

     当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：

     1. 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 `1` ；
     2. 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 `5` ；
     3. 当哈希表的负载因子小于 `0.1` 时， 程序自动开始对哈希表执行收缩操作。

  2. 如果size过大，扩容是渐进式的，将h[0]刷到h[1]，再调换。期间key直接加到h[1]

  3. 扩容和缩容的大小

     1. ht[1].size 为第一个 >= ht[0].used * 2 的  2^n

        例如： ht[0].used = 10

        10 * 2 = 20

        2^4 < 20 < 2^5=32

        h[1].size = 32

     2. 缩容是 ht[1].size 为第一个大于等于 ht[0].used 的 2^n