---
title: RabbitMQ基础面试题
category: 消息队列
typora-root-url: ..
---

1、什么是RabbitMQ？为什么使用RabbitMQ？

答：RabbitMQ是一款开源的，Erlang编写的，消息中间件；

 

2、RabbitMQ有什么优缺点？

答：

优点：

- 解耦
- 异步
- 削峰

缺点：

- 降低了系统的稳定性

  如果消息队列挂掉，程序可能出现问题。

- 增加了系统的复杂性

  一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输



3、如何保证RabbitMQ的高可用？

三种模式，单机模式，普通集群模式（一个实例工作，其他仅同步），镜像集群模式（多个实例同步，类似负载均衡）

镜像集群模式
自动把消息发送到多个队列里进行消息同步。

优点：

1. 一台机器宕机了，其他的机器还可以使用。

缺点

1. 性能消耗太大，所有机器都要进行消息的同步，导致网络压力和消耗很大。

2. 没有扩展性可言，如果有一个queue负载很重，就算加了机器，新增的机器还是包含了这个queue的所有数据，并没有办法扩展queue。



4、如何保证RabbitMQ不被重复消费？

答：重复消费原因：正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除；

但是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。

针对以上问题，一个解决思路是：保证消息的唯一性，就算是多次传输，不要让消息的多次消费带来影响；**保证消息等幂性**；

比如：在写入消息队列的数据做**全局唯一ID**，消费消息时，根据唯一标识判断是否消费过；

 

5、如何保证RabbitMQ消息的可靠传输？

答：消息不可靠的情况可能是消息丢失，劫持等原因；

丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息；

 

生产者丢失消息：

RabbitMQ提供transaction和confirm模式来确保生产者不丢消息；

transaction机制就是说：发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降；

confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后；

rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了；

如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。

 

消息队列丢数据：

消息持久化；

处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。

 

消费者丢失消息：

处理消息成功后，手动回复确认消息。

 

6、如何保证RabbitMQ消息的顺序性？

- 单线程消费保证消息的顺序性

- 对消息进行编号，消费者处理消息是根据编号处理消息